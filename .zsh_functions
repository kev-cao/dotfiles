########### git-clear #############
# git-clear function to delete all branches except master and specified exclusions
git-clear() {
  local excludes=("master")  # Always exclude master
  local branches_to_delete
  local branch
  local OPTARG OPTIND opt

  # Parse options
  while getopts "e:" opt; do
    case $opt in
      e) excludes+=("$OPTARG") ;;
      *) echo "Usage: git-clear [-e branch] (multiple -e options allowed)"; return 1 ;;
    esac
  done
  shift $((OPTIND - 1))

  # Get all branches excluding master and specified exclusions
  branches_to_delete=($(git branch --format='%(refname:short)' | grep -vE "$(IFS='|'; echo "${excludes[*]}")"))

  if [[ ${#branches_to_delete[@]} -eq 0 ]]; then
    echo "No branches to delete."
    return 0
  fi

  # Confirm deletion
  echo "The following branches will be deleted:"
  printf '%s\n' "${branches_to_delete[@]}"
  read -q "REPLY?Proceed? (y/n) "
  echo
  if [[ $REPLY != "y" ]]; then
    echo "Aborted."
    return 0
  fi

  # Delete branches
  for branch in "${branches_to_delete[@]}"; do
    git branch -D "$branch"
  done
}

# Proper Zsh autocompletion function for `git-clear`
_git-clear() {
  local branches
  branches=($(git branch --format='%(refname:short)'))

  _arguments -C \
    '(-e)--e[Exclude branch]:branch name:->branches' \
    '*-e[Exclude branch]:branch name:->branches'

  case $state in
    branches)
      compadd "${branches[@]}"
      ;;
  esac
}

# Register completion function for `git-clear`
compdef _git-clear git-clear


########## playground #############
# --- playground command + completion ---
playground() {
  local base="$HOME/playground"
  local base_pretty="~/playground"

  # Ensure base exists (create with log)
  if [[ ! -d "$base" ]]; then
    echo "Creating $base_pretty..."
    mkdir -p "$base" || { echo "Error: could not create $base_pretty"; return 1; }
  fi

  _pg_help() {
    cat <<'EOF'
Usage:
  playground                   # cd to ~/playground
  playground PATH              # cd to ~/playground/PATH (prompt to create missing tail)
  playground -d [-r] PATH...   # delete one or more PATHs under ~/playground
  playground -h                # show this help

Details:
  -d PATH...  Delete the given PATH(s) under ~/playground. Files are removed directly.
              Directories require -r. Each non-empty directory prompts:
                "Deleting <num> files in <path>. Confirm? (Y/n)"
              Empty directories (0 files, even with empty subdirs) are removed without prompting.
  -r          With -d, allows deleting directories recursively.
Notes:
  • PATH is always relative to ~/playground (no leading slash, no '..').
  • The default command creates ~/playground if needed.
EOF
  }

  # Parse options
  local opt_delete=0 opt_recursive=0
  local OPTIND=1 opt
  while getopts ":hdr" opt; do
    case "$opt" in
      h) _pg_help; return 0 ;;
      d) opt_delete=1 ;;
      r) opt_recursive=1 ;;
      \?) echo "Error: unknown option -$OPTARG. Try 'playground -h'."; return 1 ;;
    esac
  done
  shift $((OPTIND - 1))

  _pg_guard() {
    local rel="$1"
    if [[ "$rel" == /* || "$rel" == *".."* ]]; then
      echo "Error: path must be relative to $base_pretty and must not contain '..'."
      return 1
    fi
    return 0
  }

  if (( opt_delete )); then
    if [[ $# -lt 1 ]]; then
      echo "Error: -d requires at least one PATH. Try 'playground -h'."
      return 1
    fi
    local exit_code=0
    local rel target num reply
    for rel in "$@"; do
      _pg_guard "$rel" || { exit_code=1; continue; }
      rel="${rel#/}"
      target="$base/$rel"

      if [[ ! -e "$target" ]]; then
        echo "Error: '$rel' does not exist in $base_pretty."
        exit_code=1
        continue
      fi

      if [[ -d "$target" ]]; then
        if (( ! opt_recursive )); then
          echo "Error: '$rel' is a directory. Use -r to delete recursively."
          exit_code=1
          continue
        fi
        # Count files under the directory
        num=$(find "$target" -type f 2>/dev/null | wc -l | tr -d '[:space:]')
        if [[ "$num" -eq 0 ]]; then
          rm -rf -- "$target" || { echo "Error: failed to delete directory '$rel'."; exit_code=1; continue; }
          echo "Deleted empty directory '$rel'."
        else
          printf "Deleting %s files in %s. Confirm? (Y/n) " "$num" "$rel"
          read -r reply; reply="${reply:-Y}"
          case "$reply" in
            [Yy]* )
              rm -rf -- "$target" || { echo "Error: failed to delete directory '$rel'."; exit_code=1; continue; }
              echo "Deleted directory '$rel'."
              ;;
            * )
              echo "Skipped '$rel'."
              ;;
          esac
        fi
      else
        rm -f -- "$target" || { echo "Error: failed to delete '$rel'."; exit_code=1; continue; }
        echo "Deleted '$rel'."
      fi
    done
    return "$exit_code"
  fi

  # cd mode
  if [[ $# -eq 0 ]]; then
    cd "$base" || return 1
    return 0
  fi

  if [[ $# -gt 1 ]]; then
    echo "Error: too many arguments. Provide exactly one PATH for navigation (use -d to delete multiple)."
    return 1
  fi

  local rel="$1"
  _pg_guard "$rel" || return 1
  rel="${rel#/}"
  local dest="$base/$rel"

  if [[ -d "$dest" ]]; then
    cd "$dest" || return 1
    return 0
  fi

  # Find deepest existing ancestor within ~/playground
  local ancestor="$dest"
  while [[ ! -d "$ancestor" && "$ancestor" != "$base" ]]; do
    ancestor="$(dirname "$ancestor")"
  done

  local missing="${dest#"$ancestor"/}"
  local parent_rel="${ancestor#"$base"}"
  parent_rel="${parent_rel#/}"
  local display_parent="/"
  [[ -n "$parent_rel" ]] && display_parent="/$parent_rel"

  printf "%s does not exist. Create directory %s in %s (Y/n)? " "$rel" "$missing" "$display_parent"
  local reply; read -r reply; reply="${reply:-Y}"
  case "$reply" in
    [Yy]* )
      mkdir -p "$dest" || { echo "Error: could not create '$missing' in $display_parent"; cd "$ancestor" || true; return 1; }
      cd "$dest" || return 1
      ;;
    * )
      cd "$ancestor" || return 1
      ;;
  esac
}

#compdef playground

# _playground — completion for the `playground` command.
# Behavior:
#   - No -d: complete directories only (cd-like) under ~/playground; only 1 arg
#   - With -d (no -r): complete non-directories (rm-like) under ~/playground; multiple args
#   - With -d and -r: complete files AND directories (rm -r-like); multiple args
_playground() {
  local -A opt_args
  local state
  local base_dir="$HOME/playground"

  _arguments -C -s \
    '-d[delete the specified target(s) (rm-like)]' \
    '-r[recurse into directories (use with -d)]' \
    '1:target within ~/playground:->path' \
    '*:additional target(s):->more' && return

  local _complete_cd_like() {
    # directories only
    _files -W "$base_dir" -/
  }

  local _complete_rm_like() {
    # if -r is present, allow dirs too; otherwise exclude dirs
    if (( $+opt_args[-r] )); then
      _files -W "$base_dir"
    else
      # match anything that's NOT a directory (symlinks, sockets, etc. included)
      _files -W "$base_dir" -g '*(^/)'
    fi
  }

  case $state in
    path)
      if (( $+opt_args[-d] )); then
        _complete_rm_like
      else
        _complete_cd_like
      fi
      ;;
    more)
      if (( $+opt_args[-d] )); then
        _complete_rm_like
      else
        _message 'no more arguments (use -d to delete multiple targets)'
        return 1
      fi
      ;;
  esac
}

compdef _playground playground

##################################
######### CockroachLabs ##########
##################################
if [[ "$_PROFILE" != "cockroachlabs" ]]; then
  return 0
fi

function decode_backup_manifest() {
  query="WITH x AS (SHOW BACKUP FROM '$1' IN '$2' WITH as_json) SELECT jsonb_pretty(manifest) AS f FROM x LIMIT 1;"
  if [ -n "$3" ]; then
    query="WITH x AS (SHOW BACKUP FROM '$1' IN '$2' WITH as_json) SELECT jsonb_pretty(manifest) AS f FROM x OFFSET $3 LIMIT 1;"
  fi
  cockroach demo --no-example-database --sql-port 14234 --http-port 13244 --format raw -e "$query" | tail -n +4 | ghead -n -1 | jq
}

function decode_key() {
  cockroach demo --no-example-database --sql-port 14235 --http-port 13245 --format raw -e "SELECT crdb_internal.pretty_key(decode('$1', 'base64'), 0);" | tail -n +4 | ghead -n -1
}

function crdbproto() {
  if [[ "$1" == "-h" || "$1" == "--help" || -z $1 || -z $2 ]]; then
    echo "Usage: crdbproto <proto_file> <message_type>"
    echo "Example: crdbproto backup/backuppb/backup.proto BackupManifest"
    echo ""
    echo "Automatically infers package name from proto file. Reads from stdin."
    return 0
  fi

  local proto_file="$1"
  local message="$2"
  local full_path="$COCKROACH_ROOT/pkg/$proto_file"

  if [[ ! -f "$full_path" ]]; then
    echo "Error: File not found: $full_path"
    return 1
  fi

  # Extract the package name from the proto file
  local package
  package=$(rg '^package ' "$full_path" | sed -E 's/^package ([^;]+);/\1/')

  if [[ -z "$package" ]]; then
    echo "Error: Could not extract package name from $proto_file"
    return 1
  fi

  local full_message="${package}.${message}"

  protoc \
    -I "$COCKROACH_ROOT/pkg" \
    -I "$COCKROACH_ROOT/vendor/github.com/cockroachdb/errors" \
    -I "$COCKROACH_ROOT/vendor/github.com/gogo/protobuf" \
    -I "$COCKROACH_ROOT/vendor/github.com/gogo/googleapis/google/rpc" \
    --decode="$full_message" "$proto_file" < /dev/stdin
}

# _crdbproto completion function
_crdbproto() {
  local context state line
  typeset -A opt_args

  _arguments -C \
    '1:proto file:->proto_file' \
    '2:message type:->message_type' \
    && return 0

  case $state in
    proto_file)
      local proto_files
      proto_files=(${(f)"$(rg --files --glob '*.proto' --glob '!**/node_modules/**' "$COCKROACH_ROOT/pkg")"})
      proto_files=(${proto_files[@]#$COCKROACH_ROOT/pkg/})
      _values 'proto files' $proto_files
      ;;

    message_type)
      local selected_file="$words[2]"
      local full_path="$COCKROACH_ROOT/pkg/$selected_file"

      if [[ -f "$full_path" ]]; then
        local messages
        messages=(${(f)"$(rg '^message ' "$full_path" | awk '{print $2}' | sed 's/{//')"})
        _values 'message types' $messages
      fi
      ;;
  esac
}
compdef _crdbproto crdbproto
